// Code generated by internal/gen; DO NOT EDIT.
// Generated at 2025-12-07T17:54:49Z

package pumpamm

import (
	"bytes"
	"fmt"

	bin "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go"
)

var BondingCurveDiscriminator = []byte{23, 183, 248, 55, 96, 216, 172, 96}

func (a *BondingCurve) Unmarshal(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("account BondingCurve: data too short")
	}
	if !bytes.Equal(data[:8], BondingCurveDiscriminator) {
		return fmt.Errorf("account BondingCurve: discriminator mismatch")
	}
	dec := bin.NewBorshDecoder(data[8:])
	return dec.Decode(a)
}

func (a *BondingCurve) Address(pubkey solana.PublicKey) solana.PublicKey {
	return pubkey
}

var FeeConfigDiscriminator = []byte{143, 52, 146, 187, 219, 123, 76, 155}

func (a *FeeConfig) Unmarshal(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("account FeeConfig: data too short")
	}
	if !bytes.Equal(data[:8], FeeConfigDiscriminator) {
		return fmt.Errorf("account FeeConfig: discriminator mismatch")
	}
	dec := bin.NewBorshDecoder(data[8:])
	return dec.Decode(a)
}

func (a *FeeConfig) Address(pubkey solana.PublicKey) solana.PublicKey {
	return pubkey
}

var GlobalConfigDiscriminator = []byte{149, 8, 156, 202, 160, 252, 176, 217}

func (a *GlobalConfig) Unmarshal(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("account GlobalConfig: data too short")
	}
	if !bytes.Equal(data[:8], GlobalConfigDiscriminator) {
		return fmt.Errorf("account GlobalConfig: discriminator mismatch")
	}
	dec := bin.NewBorshDecoder(data[8:])
	return dec.Decode(a)
}

func (a *GlobalConfig) Address(pubkey solana.PublicKey) solana.PublicKey {
	return pubkey
}

var GlobalVolumeAccumulatorDiscriminator = []byte{202, 42, 246, 43, 142, 190, 30, 255}

func (a *GlobalVolumeAccumulator) Unmarshal(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("account GlobalVolumeAccumulator: data too short")
	}
	if !bytes.Equal(data[:8], GlobalVolumeAccumulatorDiscriminator) {
		return fmt.Errorf("account GlobalVolumeAccumulator: discriminator mismatch")
	}
	dec := bin.NewBorshDecoder(data[8:])
	return dec.Decode(a)
}

func (a *GlobalVolumeAccumulator) Address(pubkey solana.PublicKey) solana.PublicKey {
	return pubkey
}

var PoolDiscriminator = []byte{241, 154, 109, 4, 17, 177, 109, 188}

func (a *Pool) Unmarshal(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("account Pool: data too short")
	}
	if !bytes.Equal(data[:8], PoolDiscriminator) {
		return fmt.Errorf("account Pool: discriminator mismatch")
	}
	dec := bin.NewBorshDecoder(data[8:])
	return dec.Decode(a)
}

func (a *Pool) Address(pubkey solana.PublicKey) solana.PublicKey {
	return pubkey
}

var UserVolumeAccumulatorDiscriminator = []byte{86, 255, 112, 14, 102, 53, 154, 250}

func (a *UserVolumeAccumulator) Unmarshal(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("account UserVolumeAccumulator: data too short")
	}
	if !bytes.Equal(data[:8], UserVolumeAccumulatorDiscriminator) {
		return fmt.Errorf("account UserVolumeAccumulator: discriminator mismatch")
	}
	dec := bin.NewBorshDecoder(data[8:])
	return dec.Decode(a)
}

func (a *UserVolumeAccumulator) Address(pubkey solana.PublicKey) solana.PublicKey {
	return pubkey
}
